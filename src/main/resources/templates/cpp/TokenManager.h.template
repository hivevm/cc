// disable warnings on parser header files
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wunused-variable"

#ifndef JAVACC_TOKEN_MANAGER
#define JAVACC_TOKEN_MANAGER

#include <iostream>
@if(LIBRARY)
#include "ImportExport.h"
@fi
#include "JavaCC.h"
#include "Token.h"
#include "TokenManagerErrorHandler.h"

@if(NAMESPACE)
namespace {{NAMESPACE}} {
@fi

/**
 * An implementation for this interface is generated by JavaCCParser.
 * The user is free to use any implementation of their choice.
 */

@if(LIBRARY)
class {{CPP_DEFINE}}_API TokenManager {
@else
class TokenManager {
@fi
public:
    TokenManager() {
@if(DEBUG_TOKEN_MANAGER)
        trace = true;
@else
        trace = false;
@fi
    }
    virtual ~TokenManager() {}

    // This gets the next token from the input stream. A token of kind 0 (<EOF>) should be returned on EOF.
    virtual Token * getNextToken() = 0;
    virtual void lexicalError() = 0;
/*
    void setErrorHandler(TokenManagerErrorHandler* eh) {
        if (delete_eh) delete errorHandler, errorHandler = nullptr;
        delete_eh = false;  // We don't delete stuff passed in.
        errorHandler = eh;
    }
    const TokenManagerErrorHandler * getErrorHandler() const { return errorHandler; }
*/  
protected:
/*
    bool                       delete_eh = false;
    TokenManagerErrorHandler * errorHandler = nullptr;
*/
    bool                       trace;
public:
    void enable_tracing() {
@if(DEBUG_TOKEN_MANAGER)
        trace = true;
@fi
    }
    void disable_tracing(){
@if(DEBUG_TOKEN_MANAGER)
        trace = false; 
@fi
    }
    bool trace_enabled() const { return trace; }
};

@if(NAMESPACE)
}
@fi

#endif

#pragma GCC diagnostic pop