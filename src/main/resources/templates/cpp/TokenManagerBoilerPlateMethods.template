/** Reinitialise parser. */
void {{tokMgrClassName}}::ReInit(CharStream* stream, int lexState)
{
    clear();
    jjmatchedPos = jjnewStateCnt = 0;
    defaultLexState = 0;
    curLexState = 0;
    input_stream = stream;
    ReInitRounds();
    debugStream = stdout; // init
    SwitchTo(lexState);
    errorHandler = new DefaultTokenManagerErrorHandler();
}

  void {{tokMgrClassName}}::ReInitRounds() {
    int i;
    jjround = 0x80000001;
    for (i = {{stateSetSize}}; i-- > 0;)
      jjrounds[i] = 0x80000000;
  }

/** Switch to specified lex state. */
void {{tokMgrClassName}}::SwitchTo(int lexState)
{
    if (lexState > {{lexStateName}} || lexState < DEFAULT) {
      JJString message;
      message += JJWIDE(Error: Ignoring invalid lexical state : );
      message += lexState; message += JJWIDE(. State unchanged.);
      throw new TokenManagerError(message, INVALID_LEXICAL_STATE);
    } else
      curLexState = lexState;
}

void OQLTokenManager::lexicalError() {
	std::clog << "Lexical error encountered." << std::endl;
}
const  TokenManagerErrorHandler* OQLTokenManager::getErrorHandler() const {
  return errorHandler;
}

  /** Constructor. */
  {{tokMgrClassName}}::{{tokMgrClassName}}(CharStream* stream, int lexState)
  {
    input_stream = nullptr;
    ReInit(stream, lexState);
  }

  // Destructor
  {{tokMgrClassName}}::~{{tokMgrClassName}} () {
    clear();
  }

  // clear
  void {{tokMgrClassName}}::clear() {
    //Since input_stream was generated outside of TokenManager
    //TokenManager should not take care of deleting it
    //if (input_stream) delete input_stream;
    if (errorHandler) delete errorHandler, errorHandler = nullptr;    
  }


