/*
 * Copyright (c) 2001-2021 Territorium Online Srl / TOL GmbH. All Rights Reserved.
 *
 * This file contains Original Code and/or Modifications of Original Code as defined in and that are
 * subject to the Territorium Online License Version 1.0. You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at http://www.tol.info/license/
 * and read it before using this file.
 *
 * The Original Code and all software distributed under the License are distributed on an 'AS IS'
 * basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, AND TERRITORIUM ONLINE HEREBY
 * DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. Please see the License for
 * the specific language governing rights and limitations under the License.
 */

package org.javacc.generator;

import org.javacc.JavaCCContext;
import org.javacc.JavaCCRequest;
import org.javacc.parser.Expansion;
import org.javacc.parser.Lookahead;
import org.javacc.parser.NormalProduction;
import org.javacc.parser.Token;

import java.util.ArrayList;
import java.util.List;

/**
 * These lists are used to maintain expansions for which code generation in phase 2 and phase 3 is
 * required. Whenever a call is generated to a phase 2 or phase 3 routine, a corresponding entry is
 * added here if it has not already been added. The phase 3 routines have been optimized in version
 * 0.7pre2. Essentially only those methods (and only those portions of these methods) are generated
 * that are required. The lookahead amount is used to determine this. This change requires the use
 * of a hash table because it is now possible for the same phase 3 routine to be requested multiple
 * times with different lookaheads. The hash table provides a easily searchable capability to
 * determine the previous requests. The phase 3 routines now are performed in a two step process -
 * the first step gathers the requests (replacing requests with lower lookaheads with those
 * requiring larger lookaheads). The second step then generates these methods. This optimization and
 * the hashtable makes it look like we do not need the flag "phase3done" any more. But this has not
 * been removed yet.
 */
public class ParserData {

  private final JavaCCRequest request;
  private final JavaCCContext context;


  private int gensymindex;

  // maskindex, jj2index, maskVals are variables that are shared between ParseEngine and ParseGen.
  private int               jj2index;
  private boolean           jj2LA;
  private boolean           lookaheadNeeded;

  private int               maskindex;
  private final List<int[]> maskVals;

  /**
   * An array used to store the first sets generated by the following method. A true entry means
   * that the corresponding token is in the first set.
   */
  boolean[]                 firstSet;
  boolean                   xsp_declared;
  Expansion                 jj3_expansion;


  final List<Lookahead> phase2list;

  /**
   * Constructs an instance of {@link ParserData}.
   *
   * @param request
   * @param context
   */
  public ParserData(JavaCCRequest request, JavaCCContext context) {
    this.request = request;
    this.context = context;

    this.gensymindex = 0;
    this.jj2LA = false;

    this.maskindex = 0;
    this.jj2index = 0;
    this.lookaheadNeeded = false;
    this.maskVals = new ArrayList<>();
    this.phase2list = new ArrayList<>();
  }

  public final String getParserName() {
    return this.request.getParserName();
  }

  public final boolean isGenerated() {
    return this.context.isGenerated();
  }

  public final int getTokenCount() {
    return this.request.getTokenCount();
  }

  public final List<Token> toInsertionPoint1() {
    return this.request.toInsertionPoint1();
  }

  public final List<Token> toInsertionPoint2() {
    return this.request.toInsertionPoint2();
  }

  public final List<Token> fromInsertionPoint2() {
    return this.request.fromInsertionPoint2();
  }

  public final String getNameOfToken(int index) {
    return this.request.getNameOfToken(index);
  }

  public final Iterable<NormalProduction> getProductions() {
    return this.request.getNormalProductions();
  }

  public final NormalProduction getProduction(String name) {
    return this.request.getProductionTable(name);
  }

  public final int maskIndex() {
    return this.maskindex;
  }

  public final int addMaskIndex() {
    return this.maskindex++;
  }

  protected final void addMaskVals(int[] maskVal) {
    this.maskVals.add(maskVal);
  }

  public final boolean isLookAheadNeeded() {
    return this.lookaheadNeeded;
  }

  public final void setLookAheadNeeded(boolean lookaheadNeeded) {
    this.lookaheadNeeded = lookaheadNeeded;
  }

  public final int jj2Index() {
    return this.jj2index;
  }

  public final boolean isJJ2LA() {
    return this.jj2LA;
  }

  public final void setJJ2LA(boolean jj2LA) {
    this.jj2LA = jj2LA;
  }

  public final int addJJ2Index() {
    return ++this.jj2index;
  }

  public final List<int[]> maskVals() {
    return this.maskVals;
  }

  public final int nextGenSymIndex() {
    return ++this.gensymindex;
  }
}
