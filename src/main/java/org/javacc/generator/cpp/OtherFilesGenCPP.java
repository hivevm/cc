// Copyright 2012 Google Inc. All Rights Reserved.
// Author: sreeni@google.com (Sreeni Viswanadha)

/*
 * Copyright (c) 2006, Sun Microsystems, Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted
 * provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this list of conditions
 * and the following disclaimer. * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the documentation and/or other
 * materials provided with the distribution. * Neither the name of the Sun Microsystems, Inc. nor
 * the names of its contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.javacc.generator.cpp;

import org.javacc.JavaCC;
import org.javacc.JavaCCContext;
import org.javacc.generator.JavaCCToken;
import org.javacc.generator.JavaCCTokenInsertion;
import org.javacc.generator.LexerData;
import org.javacc.parser.JavaCCErrors;
import org.javacc.parser.Options;
import org.javacc.parser.ParseException;
import org.javacc.parser.RStringLiteral;
import org.javacc.parser.RegExprSpec;
import org.javacc.parser.RegularExpression;
import org.javacc.parser.TokenProduction;

import java.util.List;

/**
 * Generates the Constants file.
 */
public class OtherFilesGenCPP {

  public static void start(LexerData data, JavaCCContext context) throws ParseException {
    if (JavaCCErrors.hasError()) {
      throw new ParseException();
    }

    CPPFiles.gen_JavaCCDefs();
    CPPFiles.gen_CharStream();
    CPPFiles.gen_Token(); // TODO(theov): issued twice??
    CPPFiles.gen_TokenManager();
    CPPFiles.gen_TokenMgrError();
    CPPFiles.gen_ParseException();
    CPPFiles.gen_ErrorHandler();

    try {
      OtherFilesGenCPP.ostr =
          new java.io.PrintWriter(
              new java.io.BufferedWriter(
                  new java.io.FileWriter(
                      new java.io.File(Options.getOutputDirectory(), data.request.getParserName() + "Constants.h")),
                  8192));
    } catch (java.io.IOException e) {
      JavaCCErrors.semantic_error("Could not open file " + data.request.getParserName() + "Constants.h for writing.");
      throw new Error();
    }

    List<String> tn = context.getToolNames();
    tn.add(JavaCC.TOOLNAME);

    OtherFilesGenCPP.ostr.println("/* " + JavaCCToken.getIdString(tn) + " */");
    JavaCCTokenInsertion.printTokenSetup(OtherFilesGenCPP.ostr, data.request);
    OtherFilesGenCPP.ostr.println("");
    OtherFilesGenCPP.ostr.println("/**");
    OtherFilesGenCPP.ostr.println(" * Token literal values and constants.");
    OtherFilesGenCPP.ostr.println(" * Generated by org.javacc.parser.OtherFilesGenCPP#start()");
    OtherFilesGenCPP.ostr.println(" */");

    String define = ("JAVACC_" + data.request.getParserName() + "Constants_h").toUpperCase();
    OtherFilesGenCPP.ostr.println("#ifndef " + define);
    OtherFilesGenCPP.ostr.println("#define " + define);
    OtherFilesGenCPP.ostr.println("");
    OtherFilesGenCPP.ostr.println("#include \"JavaCC.h\"");
    OtherFilesGenCPP.ostr.println("");
    if (Options.stringValue(JavaCC.JJPARSER_CPP_NAMESPACE).length() > 0) {
      OtherFilesGenCPP.ostr.println("namespace " + Options.stringValue(JavaCC.JJPARSER_CPP_NAMESPACE) + " {");
    }

    String constPrefix = "const";
    OtherFilesGenCPP.ostr.println("  /** End of File. */");
    OtherFilesGenCPP.ostr.println(constPrefix + "  int _EOF = 0;");
    for (RegularExpression re : data.request.getOrderedsTokens()) {
      OtherFilesGenCPP.ostr.println("  /** RegularExpression Id. */");
      OtherFilesGenCPP.ostr.println(constPrefix + "  int " + re.label + " = " + re.ordinal + ";");
    }
    OtherFilesGenCPP.ostr.println("");

    for (int i = 0; i < data.getStateCount(); i++) {
      OtherFilesGenCPP.ostr.println("  /** Lexical state. */");
      OtherFilesGenCPP.ostr.println(constPrefix + "  int " + data.getStateName(i) + " = " + i + ";");
    }
    OtherFilesGenCPP.ostr.println("");
    OtherFilesGenCPP.ostr.println("  /** Literal token image. */");
    int cnt = 0;
    OtherFilesGenCPP.ostr.println("  static const JJChar tokenImage_" + cnt + "[] = ");
    OtherFilesGenCPP.printCharArray(OtherFilesGenCPP.ostr, "<EOF>");
    OtherFilesGenCPP.ostr.println(";");

    for (TokenProduction tp : data.request.getTokenProductions()) {
      List<RegExprSpec> respecs = tp.respecs;
      for (RegExprSpec res : respecs) {
        RegularExpression re = res.rexp;
        OtherFilesGenCPP.ostr.println("  static const JJChar tokenImage_" + ++cnt + "[] = ");
        if (re instanceof RStringLiteral) {
          OtherFilesGenCPP.printCharArray(OtherFilesGenCPP.ostr, ((RStringLiteral) re).image);
        } else if (!re.label.equals("")) {
          OtherFilesGenCPP.printCharArray(OtherFilesGenCPP.ostr, "<" + re.label + ">");
        } else {
          if (re.tpContext.kind == TokenProduction.TOKEN) {
            JavaCCErrors.warning(re, "Consider giving this non-string token a label for better error reporting.");
          }
          OtherFilesGenCPP.printCharArray(OtherFilesGenCPP.ostr, "<token of kind " + re.ordinal + ">");
        }
        OtherFilesGenCPP.ostr.println(";");
      }
    }

    OtherFilesGenCPP.ostr.println("  static const JJChar* const tokenImages[] = {");
    for (int i = 0; i <= cnt; i++) {
      OtherFilesGenCPP.ostr.println("tokenImage_" + i + ", ");
    }
    OtherFilesGenCPP.ostr.println("  };");


    OtherFilesGenCPP.ostr.println("  /** Literal token label. */");
    cnt = 0;
    OtherFilesGenCPP.ostr.println("  static const JJChar tokenLabel_" + cnt + "[] = ");
    OtherFilesGenCPP.printCharArray(OtherFilesGenCPP.ostr, "<EOF>");
    OtherFilesGenCPP.ostr.println(";");

    for (TokenProduction tp : data.request.getTokenProductions()) {
      List<RegExprSpec> respecs = tp.respecs;
      for (RegExprSpec res : respecs) {
        RegularExpression re = res.rexp;
        OtherFilesGenCPP.ostr.println("  static const JJChar tokenLabel_" + ++cnt + "[] = ");
        if (re instanceof RStringLiteral) {
          OtherFilesGenCPP.printCharArray(OtherFilesGenCPP.ostr, "<" + ((RStringLiteral) re).label + ">");
        } else if (!re.label.equals("")) {
          OtherFilesGenCPP.printCharArray(OtherFilesGenCPP.ostr, "<" + re.label + ">");
        } else {
          if (re.tpContext.kind == TokenProduction.TOKEN) {
            JavaCCErrors.warning(re, "Consider giving this non-string token a label for better error reporting.");
          }
          OtherFilesGenCPP.printCharArray(OtherFilesGenCPP.ostr, "<token of kind " + re.ordinal + ">");
        }
        OtherFilesGenCPP.ostr.println(";");
      }
    }

    OtherFilesGenCPP.ostr.println("  static const JJChar* const tokenLabels[] = {");
    for (int i = 0; i <= cnt; i++) {
      OtherFilesGenCPP.ostr.println("tokenLabel_" + i + ", ");
    }
    OtherFilesGenCPP.ostr.println("  };");
    OtherFilesGenCPP.ostr.println();

    OtherFilesGenCPP.ostr.println("");
    if (Options.stringValue(JavaCC.JJPARSER_CPP_NAMESPACE).length() > 0) {
      OtherFilesGenCPP.ostr.println("}");
    }
    OtherFilesGenCPP.ostr.println("#endif");
    OtherFilesGenCPP.ostr.close();

  }

  // Used by the CPP code generatror
  static void printCharArray(java.io.PrintWriter ostr, String s) {
    ostr.print("{");
    for (int i = 0; i < s.length(); i++) {
      ostr.print("0x" + Integer.toHexString(s.charAt(i)) + ", ");
    }
    ostr.print("0}");
  }

  static private java.io.PrintWriter ostr;
}
