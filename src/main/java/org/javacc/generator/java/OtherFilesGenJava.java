// Copyright 2011 Google Inc. All Rights Reserved.
// Author: sreeni@google.com (Sreeni Viswanadha)

/*
 * Copyright (c) 2006, Sun Microsystems, Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted
 * provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this list of conditions
 * and the following disclaimer. * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the documentation and/or other
 * materials provided with the distribution. * Neither the name of the Sun Microsystems, Inc. nor
 * the names of its contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.javacc.generator.java;

import org.fastcc.utils.DigestOptions;
import org.fastcc.utils.DigestWriter;
import org.fastcc.utils.Encoding;
import org.javacc.JavaCC;
import org.javacc.JavaCCContext;
import org.javacc.JavaCCVersion;
import org.javacc.generator.JavaCCToken;
import org.javacc.generator.LexerData;
import org.javacc.generator.java.JavaFiles.JavaResourceTemplateLocations;
import org.javacc.parser.JavaCCErrors;
import org.javacc.parser.Options;
import org.javacc.parser.ParseException;
import org.javacc.parser.RStringLiteral;
import org.javacc.parser.RegExprSpec;
import org.javacc.parser.RegularExpression;
import org.javacc.parser.TokenProduction;

import java.io.File;
import java.io.IOException;
import java.util.List;

/**
 * Generates the Constants file.
 */
public class OtherFilesGenJava {

  private static final String CONSTANTS_FILENAME_SUFFIX = "Constants.java";

  static public void start(LexerData data, JavaCCContext context) throws ParseException {

    JavaResourceTemplateLocations templateLoc = JavaFiles.RESOURCES_JAVA_MODERN;


    if (JavaCCErrors.hasError()) {
      throw new ParseException();
    }

    // Added this if condition -- 2012/10/17 -- cba
    JavaFiles.gen_JavaModernFiles(data.request);

    JavaFiles.gen_TokenMgrError(data.request, templateLoc);
    JavaFiles.gen_ParseException(data.request, templateLoc);
    JavaFiles.gen_Token(data.request, templateLoc);
    JavaFiles.gen_JavaCharStream(data.request, templateLoc);

    File file = new java.io.File(Options.getOutputDirectory(),
        data.request.getParserName() + OtherFilesGenJava.CONSTANTS_FILENAME_SUFFIX);
    try (DigestWriter ostr = DigestWriter.create(file, JavaCCVersion.VERSION, DigestOptions.get())) {

      final List<String> tn = context.getToolNames();
      tn.add(JavaCC.TOOLNAME);

      ostr.println("/* " + JavaCCToken.getIdString(tn) + " */");
      JavaCCToken.printTokenSetup(ostr, data.request.toInsertionPoint1());
      ostr.println("");
      ostr.println("/**");
      ostr.println(" * Token literal values and constants.");
      ostr.println(" * Generated by org.javacc.parser.OtherFilesGen#start()");
      ostr.println(" */");

      ostr.print("public ");
      ostr.println("interface " + data.request.getParserName() + "Constants {");
      ostr.println("");

      ostr.println("  /** End of File. */");
      ostr.println("  int EOF = 0;");
      for (RegularExpression re : data.request.getOrderedsTokens()) {
        ostr.println("  /** RegularExpression Id. */");
        ostr.println("  int " + re.label + " = " + re.ordinal + ";");
      }
      ostr.println("");
      for (int i = 0; i < data.getStateCount(); i++) {
        ostr.println("  /** Lexical state. */");
        ostr.println("  int " + data.getStateName(i) + " = " + i + ";");
      }
      ostr.println("");
      ostr.println("  /** Literal token values. */");
      ostr.println("  String[] tokenImage = {");
      ostr.println("    \"<EOF>\",");

      for (TokenProduction tokenProduction : data.request.getTokenProductions()) {
        TokenProduction tp = (tokenProduction);
        List<RegExprSpec> respecs = tp.respecs;
        for (RegExprSpec respec : respecs) {
          RegExprSpec res = (respec);
          RegularExpression re = res.rexp;
          ostr.print("    ");
          if (re instanceof RStringLiteral) {
            ostr.println("\"\\\"" + Encoding.escape(Encoding.escape(((RStringLiteral) re).image)) + "\\\"\",");
          } else if (!re.label.equals("")) {
            ostr.println("\"<" + re.label + ">\",");
          } else {
            if (re.tpContext.kind == TokenProduction.TOKEN) {
              JavaCCErrors.warning(re, "Consider giving this non-string token a label for better error reporting.");
            }
            ostr.println("\"<token of kind " + re.ordinal + ">\",");
          }

        }
      }
      ostr.println("  };");
      ostr.println("");
      ostr.println("}");

    } catch (IOException e) {
      JavaCCErrors
          .semantic_error("Could not open file " + data.request.getParserName() + "Constants.java for writing.");
      throw new Error();
    }
  }
}
