// Copyright 2024 HiveVM.ORG. All rights reserved.
// SPDX-License-Identifier: BSD-3-Clause

package org.hivevm.cc.generator;

import org.hivevm.cc.ParserRequest;
import org.hivevm.cc.parser.Action;
import org.hivevm.cc.parser.Choice;
import org.hivevm.cc.parser.Expansion;
import org.hivevm.cc.parser.Lookahead;
import org.hivevm.cc.parser.NonTerminal;
import org.hivevm.cc.parser.NormalProduction;
import org.hivevm.cc.parser.OneOrMore;
import org.hivevm.cc.parser.Options;
import org.hivevm.cc.parser.RegularExpression;
import org.hivevm.cc.parser.Sequence;
import org.hivevm.cc.parser.ZeroOrMore;
import org.hivevm.cc.parser.ZeroOrOne;
import org.hivevm.cc.semantic.Semanticize;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;

/**
 * These lists are used to maintain expansions for which code generation in phase 2 and phase 3 is
 * required. Whenever a call is generated to a phase 2 or phase 3 routine, a corresponding entry is
 * added here if it has not already been added. The phase 3 routines have been optimized in version
 * 0.7pre2. Essentially only those methods (and only those portions of these methods) are generated
 * that are required. The lookahead amount is used to determine this. This change requires the use
 * of a hash table because it is now possible for the same phase 3 routine to be requested multiple
 * times with different lookaheads. The hash table provides a easily searchable capability to
 * determine the previous requests. The phase 3 routines now are performed in a two step process -
 * the first step gathers the requests (replacing requests with lower lookaheads with those
 * requiring larger lookaheads). The second step then generates these methods. This optimization and
 * the hashtable makes it look like we do not need the flag "phase3done" any more. But this has not
 * been removed yet.
 */
public class ParserData {

  private final ParserRequest request;


  // maskindex, jj2index, maskVals are variables that are shared between ParseEngine and ParseGen.
  private int                               jj2index;
  private boolean                           lookaheadNeeded;

  private final List<int[]>                 maskVals;
  private final Map<Expansion, Lookahead[]> lookaheads;
  private final Map<Lookahead, Integer>     lookaheadIndex;

  /**
   * An array used to store the first sets generated by the following method. A true entry means
   * that the corresponding token is in the first set.
   */
  private final List<Lookahead>             phase2list;
  final List<Phase3Data>                    phase3list  = new ArrayList<>();
  final Hashtable<Expansion, Integer>       phase3table = new Hashtable<>();

  /**
   * Constructs an instance of {@link ParserData}.
   *
   * @param request
   */
  ParserData(ParserRequest request) {
    this.request = request;

    this.jj2index = 0;
    this.lookaheadNeeded = false;
    this.maskVals = new ArrayList<>();
    this.phase2list = new ArrayList<>();
    this.lookaheads = new HashMap<>();
    this.lookaheadIndex = new HashMap<>();
  }

  public final Options options() {
    return this.request.options();
  }

  public final String getParserName() {
    return this.request.getParserName();
  }

  public final boolean isGenerated() {
    return this.request.isGenerated();
  }

  public final int getTokenCount() {
    return this.request.getTokenCount();
  }

  public final String getNameOfToken(int index) {
    return this.request.getNameOfToken(index);
  }

  public final Iterable<NormalProduction> getProductions() {
    return this.request.getNormalProductions();
  }

  public final NormalProduction getProduction(String name) {
    return this.request.getProductionTable(name);
  }

  public final int maskIndex() {
    return this.maskVals.size();
  }

  public final List<int[]> maskVals() {
    return this.maskVals;
  }

  public final boolean isLookAheadNeeded() {
    return this.lookaheadNeeded;
  }

  public final Iterable<Lookahead> getLoakaheads() {
    return this.phase2list;
  }

  public final Iterable<Expansion> getExpansions() {
    return this.phase3table.keySet();
  }

  public final int getCount(Expansion e) {
    return this.phase3table.get(e);
  }

  public final Lookahead[] getLoakaheads(Expansion e) {
    return this.lookaheads.get(e);
  }

  public final int getIndex(Lookahead lookahead) {
    return this.lookaheadIndex.get(lookahead);
  }

  public final int jj2Index() {
    return this.jj2index;
  }

  protected final void addMask(int[] maskVal, Lookahead lookahead) {
    this.lookaheadIndex.put(lookahead, maskIndex());
    this.maskVals.add(maskVal);
  }

  protected final int addLookupAhead(Lookahead lookahead) {
    this.phase2list.add(lookahead);
    return ++this.jj2index;
  }

  protected final void setLookupAhead(Expansion e, Lookahead[] lookaheads) {
    this.lookaheads.put(e, lookaheads);
  }


  protected final void addExpansion(Lookahead la) {
    Expansion e = la.getLaExpansion();
    Phase3Data p3d = new Phase3Data(e, la.getAmount());
    this.phase3list.add(p3d);
    this.phase3table.put(e, la.getAmount());
  }

  protected final void setLookAheadNeeded(boolean lookaheadNeeded) {
    this.lookaheadNeeded = lookaheadNeeded;
  }

  /**
   * Sets up the array "firstSet" above based on the Expansion argument passed to it. Since this is
   * a recursive function, it assumes that "firstSet" has been reset before the first call.
   */
  public final boolean genFirstSet(Expansion exp, boolean[] firstSet, boolean jj2la) {
    if (exp instanceof RegularExpression) {
      firstSet[((RegularExpression) exp).getOrdinal()] = true;
    } else if (exp instanceof NonTerminal) {
      jj2la = genFirstSet((((NonTerminal) exp).getProd()).getExpansion(), firstSet, jj2la);
    } else if (exp instanceof Choice) {
      Choice ch = (Choice) exp;
      for (Object element : ch.getChoices()) {
        jj2la = genFirstSet((Expansion) (element), firstSet, jj2la);
      }
    } else if (exp instanceof Sequence) {
      Sequence seq = (Sequence) exp;
      Object obj = seq.getUnits().get(0);
      if ((obj instanceof Lookahead) && (((Lookahead) obj).getActionTokens().size() != 0)) {
        jj2la = true;
      }
      for (Object element : seq.getUnits()) {
        // Javacode productions can not have FIRST sets. Instead we generate the FIRST set
        // for the preceding LOOKAHEAD (the semantic checks should have made sure that
        // the LOOKAHEAD is suitable).
        jj2la = genFirstSet((Expansion) (element), firstSet, jj2la);
        if (!Semanticize.emptyExpansionExists((Expansion) (element))) {
          break;
        }
      }
    } else if (exp instanceof OneOrMore) {
      OneOrMore om = (OneOrMore) exp;
      jj2la = genFirstSet(om.getExpansion(), firstSet, jj2la);
    } else if (exp instanceof ZeroOrMore) {
      ZeroOrMore zm = (ZeroOrMore) exp;
      jj2la = genFirstSet(zm.getExpansion(), firstSet, jj2la);
    } else if (exp instanceof ZeroOrOne) {
      ZeroOrOne zo = (ZeroOrOne) exp;
      jj2la = genFirstSet(zo.getExpansion(), firstSet, jj2la);
    }
    return jj2la;
  }

  /*
   * Returns the minimum number of tokens that can parse to this expansion.
   */
  public final int minimumSize(Expansion e) {
    return minimumSize(e, Integer.MAX_VALUE);
  }

  /*
   * Returns the minimum number of tokens that can parse to this expansion.
   */
  private int minimumSize(Expansion e, int oldMin) {
    int retval = 0; // should never be used. Will be bad if it is.
    if (e.inMinimumSize) {
      // recursive search for minimum size unnecessary.
      return Integer.MAX_VALUE;
    }
    e.inMinimumSize = true;
    if (e instanceof RegularExpression) {
      retval = 1;
    } else if (e instanceof NonTerminal) {
      NonTerminal e_nrw = (NonTerminal) e;
      NormalProduction ntprod = getProduction(e_nrw.getName());
      Expansion ntexp = ntprod.getExpansion();
      retval = minimumSize(ntexp);
    } else if (e instanceof Choice) {
      int min = oldMin;
      Expansion nested_e;
      Choice e_nrw = (Choice) e;
      for (int i = 0; (min > 1) && (i < e_nrw.getChoices().size()); i++) {
        nested_e = (e_nrw.getChoices().get(i));
        int min1 = minimumSize(nested_e, min);
        if (min > min1) {
          min = min1;
        }
      }
      retval = min;
    } else if (e instanceof Sequence) {
      int min = 0;
      Sequence e_nrw = (Sequence) e;
      // We skip the first element in the following iteration since it is the
      // Lookahead object.
      for (int i = 1; i < e_nrw.getUnits().size(); i++) {
        Expansion eseq = (Expansion) (e_nrw.getUnits().get(i));
        int mineseq = minimumSize(eseq);
        if ((min == Integer.MAX_VALUE) || (mineseq == Integer.MAX_VALUE)) {
          min = Integer.MAX_VALUE; // Adding infinity to something results in infinity.
        } else {
          min += mineseq;
          if (min > oldMin) {
            break;
          }
        }
      }
      retval = min;
    } else if (e instanceof OneOrMore) {
      OneOrMore e_nrw = (OneOrMore) e;
      retval = minimumSize(e_nrw.getExpansion(), Integer.MAX_VALUE);
    } else if (e instanceof ZeroOrMore) {
      retval = 0;
    } else if (e instanceof ZeroOrOne) {
      retval = 0;
    } else if (e instanceof Lookahead) {
      retval = 0;
    } else if (e instanceof Action) {
      retval = 0;
    }
    e.inMinimumSize = false;
    return retval;
  }

  /**
   * This class stores information to pass from phase 2 to phase 3.
   */
  class Phase3Data {

    // This is the expansion to generate the jj3 method for.
    final Expansion exp;

    // This is the number of tokens that can still be consumed. This number is used to limit the
    // number of jj3 methods generated.
    final int count;

    Phase3Data(Expansion e, int c) {
      this.exp = e;
      this.count = c;
    }
  }
}
