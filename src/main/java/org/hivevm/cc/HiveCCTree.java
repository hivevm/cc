// Copyright 2024 HiveVM.ORG. All rights reserved.
// SPDX-License-Identifier: BSD-3-Clause

package org.hivevm.cc;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.Reader;
import java.text.ParseException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.hivevm.cc.generator.ParserEngine;
import org.hivevm.cc.jjtree.ASTGrammar;
import org.hivevm.cc.jjtree.ASTWriter;
import org.hivevm.cc.jjtree.JJTreeGlobals;
import org.hivevm.cc.jjtree.JJTreeOptions;
import org.hivevm.cc.jjtree.JJTreeParserDefault;
import org.hivevm.cc.parser.JavaCCErrors;
import org.hivevm.cc.parser.Options;

public class HiveCCTree {

  private static final Pattern GENERATED = Pattern.compile("@generated\\(([^\\)]+)\\)");

  /**
   * Writes the generated string.
   * 
   * @param writer
   */
  private static void writeGenerated(PrintWriter writer) {
    writer.println("/* @generated(JJTree) */");
  }

  /**
   * Parses the tool list from the generated string.
   * 
   * @param text
   */
  private static List<String> readToolNameList(String text) {
    Matcher matcher = HiveCCTree.GENERATED.matcher(text);
    while (matcher.find()) {
      return Arrays.asList(matcher.group(1).split(","));
    }
    return Collections.emptyList();
  }

  /**
   * Returns true if tool name passed is one of the tool names returned by getToolNames(fileName).
   *
   * @param fileName
   */
  static boolean isGenerated(String fileName) {
    try (InputStream stream = new FileInputStream(fileName)) {
      String data = new String(stream.readAllBytes());
      for (String element : HiveCCTree.readToolNameList(data)) {
        if ("JJTree".equals(element)) {
          return true;
        }
      }
    } catch (IOException e) {}
    return false;
  }


  private static File createTreeFile(String i, JJTreeOptions options) {
    String filename = options.getOutputFile();

    if (filename.equals("")) {
      int s = i.lastIndexOf(File.separatorChar);
      if (s >= 0) {
        i = i.substring(s + 1);
      }

      int di = i.lastIndexOf('.');
      if (di == -1) {
        filename = i + ".jj";
      } else {
        String suffix = i.substring(di);
        if (suffix.equals(".jj")) {
          filename = i + ".jj";
        } else {
          filename = i.substring(0, di) + ".jj";
        }
      }
    }

    return new File(options.getOutputDirectory(), filename);
  }

  /**
   * A main program that exercises the parser.
   */
  public static void main(String args[]) {
    HiveCCTools.bannerLine("Tree Builder", "");

    JavaCCErrors.reInit();
    JJTreeGlobals.initialize();

    if (args.length == 0) {
      System.err.println("");
      System.err.println("Missing arguments");
      System.exit(1);
    }

    String fn = args[args.length - 1];

    JJTreeOptions options = new JJTreeOptions();
    if (options.isOption(fn)) {
      System.out.println("Last argument \"" + fn + "\" is not a filename");
      System.exit(1);
    }

    for (int arg = 0; arg < (args.length - 1); arg++) {
      if (!options.isOption(args[arg])) {
        System.out.println("Argument \"" + args[arg] + "\" must be an option setting.");
        System.exit(1);
      }
      options.setCmdLineOption(args[arg]);
    }
    options.validate();

    HiveCCTools.createOutputDir(options.getOutputDirectory());
    File jjFile = HiveCCTree.createTreeFile(fn, options);

    try {
      if (HiveCCTree.isGenerated(fn)) {
        throw new IOException(fn + " was generated by jjtree.  Cannot run jjtree again.");
      }

      System.out.println("Reading from file " + fn + " ...");

      try (Reader reader = new InputStreamReader(new FileInputStream(fn), options.getGrammarEncoding())) {
        JJTreeParserDefault parser = new JJTreeParserDefault(reader, options);
        ASTGrammar root = parser.parse();
        if (Boolean.getBoolean("jjtree-dump")) {
          root.dump(" ");
        }

        System.out.println("opt:" + Options.getOutputLanguage());

        ParserEngine engine = ParserEngine.create(Options.getOutputLanguage());

        try (ASTWriter writer = new ASTWriter(jjFile, Options.getOutputLanguage())) {
          HiveCCTree.writeGenerated(writer);
          engine.generateAbstractSyntaxTree(root, writer, options);
        } catch (IOException ioe) {
          System.out.println("Error setting input: " + ioe.getMessage());
          System.exit(1);
        }

        System.out.println("Annotated grammar generated successfully in " + jjFile.toString());

      } catch (ParseException pe) {
        System.out.println("Error parsing input: " + pe.toString());
        System.exit(1);
      } catch (Exception e) {
        System.out.println("Error parsing input: " + e.toString());
        e.printStackTrace(System.out);
        System.exit(1);
      }

    } catch (IOException ioe) {
      System.out.println("Error setting input: " + ioe.getMessage());
      System.exit(1);
    }
  }
}
